<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cylinder 3D - Debug Mode</title>
    <style>
        body { margin: 0; background: #111; overflow: hidden; touch-action: none; color: white; }
        #container {
            width: 100vw; height: 100vh;
            display: flex; align-items: center; justify-content: center;
            perspective: 2000px; 
        }
        #cylinder-root {
            position: relative;
            transform-style: preserve-3d;
            transform: scale(0.6) rotateX(-22deg);
            width: 275px; height: 355px;
            /* 中央位置を視覚化 */
            border: 1px dashed #444; 
        }
        .panel {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            transform-style: preserve-3d;
            background: #222; /* 画像がない時に板が見えるように */
            border: 1px solid #333;
        }
        .card-img {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: fill; pointer-events: none;
        }
        .zebra { transform: scaleX(-1); background: #333; }
        #page-indicator {
            position: fixed; top: 30px; width: 100%; text-align: center;
            font-size: 24px; font-weight: bold; z-index: 10;
        }
    </style>
</head>
<body>

<div id="page-indicator">Index: 0 (Initializing...)</div>
<div id="container">
    <div id="cylinder-root"></div>
</div>

<script>
    const panelImages = ['2queen_b.webp', '2king_b.webp', '2jack_b.webp', '2joker1_b.webp', '2joker2_b.webp'];
    const backImage = '2zebra_b.webp';
    const totalPanelCount = 6;
    const stepAngle = 360 / totalPanelCount;
    const cylinderZ = 300;

    let angle = 0.0, mode = 2, currentSpeed = 0.5, dragSpeed = 0.0;
    let isTouching = false, startTime = null, targetAngle = null;
    let lastReportedSeat = -1, totalStepCount = 0, currentIndex = 0;

    const root = document.getElementById('cylinder-root');
    const indicator = document.getElementById('page-indicator');
    const panels = [];

    function setup() {
        console.log("Setting up panels...");
        for (let i = 0; i < totalPanelCount; i++) {
            const panel = document.createElement('div');
            panel.className = 'panel';
            
            const zebra = document.createElement('img');
            zebra.src = backImage; // 裸のパス
            zebra.className = 'card-img zebra';
            
            const frontGroup = document.createElement('div');
            frontGroup.style.cssText = 'position:absolute; width:100%; height:100%; transform-style:preserve-3d;';
            
            const imgA = document.createElement('img');
            imgA.className = 'card-img';
            const imgB = document.createElement('img');
            imgB.className = 'card-img';
            
            frontGroup.appendChild(imgA);
            frontGroup.appendChild(imgB);
            panel.appendChild(zebra);
            panel.appendChild(frontGroup);
            root.appendChild(panel);
            
            panels.push({ el: panel, group: frontGroup, imgA, imgB });
        }
        indicator.innerText = "Index: 0 (Running)";
        update(); // ループ開始
    }

    function update() {
        if (mode === 5) return;
        dragSpeed *= 0.95;
        angle += (currentSpeed + dragSpeed);

        // インデックス計算
        const currentSeat = Math.round(angle / stepAngle);
        if (lastReportedSeat !== currentSeat) {
            let diff = (lastReportedSeat === -1) ? 0 : currentSeat - lastReportedSeat;
            totalStepCount += diff;
            lastReportedSeat = currentSeat;
            let visualIndex = ((totalStepCount % 5) + 5) % 5;
            if (currentIndex !== visualIndex) {
                currentIndex = visualIndex;
                indicator.innerText = `Index: ${currentIndex}`;
            }
        }

        // 加速ロジック
        const now = Date.now();
        if (mode === 2) {
            let target = (startTime) ? 0.5 + (Math.min(now - startTime, 20000) / 1000) : (isTouching ? 4.0 : 0.5);
            if (startTime && (now - startTime >= 20000)) mode = 3;
            currentSpeed += (target - currentSpeed) * 0.05;
        } else if (mode === 3) {
            currentSpeed *= 0.98;
            if (currentSpeed < 1.2) { mode = 4; targetAngle = Math.round(angle / stepAngle) * stepAngle; }
        } else if (mode === 4) {
            let distance = targetAngle - angle;
            currentSpeed = (currentSpeed * 0.92) + distance * 0.04;
            if (Math.abs(distance) < 0.01 && Math.abs(currentSpeed) < 0.01) { angle = targetAngle; mode = 5; }
        }

        render();
        requestAnimationFrame(update);
    }

    function render() {
        panels.forEach((p, i) => {
            const rad = (i * stepAngle + angle) * Math.PI / 180;
            const z = Math.cos(rad);
            const rawTurns = (rad * 180 / Math.PI + 100) / 360;
            const currentTurns = Math.floor(rawTurns);
            
            let idxA = ((i - currentTurns) % 5 + 5) % 5;
            let idxB = ((i - (currentTurns + 1)) % 5 + 5) % 5;
            const progress = rawTurns - currentTurns;
            const fadeValue = Math.min(Math.max((progress - 0.5) / 0.5, 0.0), 1.0);
            const frontOpacity = Math.min(Math.max((z * 8) + 0.5, 0.0), 1.0);
            const brightness = Math.min(Math.max((z + 1.2) / 2.2, 0.2), 1.0);

            p.el.style.transform = `rotateY(${rad}rad) translateZ(${cylinderZ}px) rotateX(1deg)`;
            p.group.style.opacity = frontOpacity;
            p.group.style.filter = `brightness(${brightness})`;
            
            // srcの変更を最小限に
            const srcA = panelImages[idxA];
            const srcB = panelImages[idxB];
            if (!p.imgA.src.endsWith(srcA)) p.imgA.src = srcA;
            if (!p.imgB.src.endsWith(srcB)) p.imgB.src = srcB;
            
            p.imgA.style.opacity = 1 - fadeValue;
            p.imgB.style.opacity = fadeValue;
        });
    }

    // タッチ・ドラッグイベント
    let lastX = 0;
    const start = (e) => { isTouching = true; lastX = e.clientX || (e.touches ? e.touches[0].clientX : 0); };
    const move = (e) => { 
        if(!isTouching) return;
        const x = e.clientX || (e.touches ? e.touches[0].clientX : 0);
        const dx = x - lastX;
        angle += dx * 0.4; dragSpeed = dx * 0.4; lastX = x;
    };
    const end = () => isTouching = false;

    window.addEventListener('mousedown', start);
    window.addEventListener('mousemove', move);
    window.addEventListener('mouseup', end);
    window.addEventListener('touchstart', start, {passive: false});
    window.addEventListener('touchmove', move, {passive: false});
    window.addEventListener('touchend', end);

    // 10秒待たずに即時実行準備
    setup(); 
    // 5秒後に自動加速開始（動作確認を早めるため）
    setTimeout(() => { if (!startTime) startTime = Date.now(); }, 5000);

</script>
</body>
</html>
